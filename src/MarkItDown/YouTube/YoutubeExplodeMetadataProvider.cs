using System.Globalization;
using System.Linq;
using MarkItDown.Intelligence.Models;
using YoutubeExplode;
using YoutubeExplode.Common;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;

namespace MarkItDown.YouTube;

/// <summary>
/// Default YouTube metadata provider built on top of <c>YoutubeExplode</c>.
/// </summary>
public sealed class YoutubeExplodeMetadataProvider : IYouTubeMetadataProvider
{
    private readonly YoutubeClient client;

    public YoutubeExplodeMetadataProvider(YoutubeClient? client = null)
    {
        this.client = client ?? new YoutubeClient();
    }

    public async Task<YouTubeMetadata?> GetVideoAsync(string videoId, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(videoId))
        {
            return null;
        }

        try
        {
            var id = VideoId.TryParse(videoId);
            if (!id.HasValue)
            {
                return null;
            }

            var video = await client.Videos.GetAsync(id.Value, cancellationToken).ConfigureAwait(false);

            var captions = await TryGetCaptionsAsync(id.Value, cancellationToken).ConfigureAwait(false);
            var thumbnails = video.Thumbnails
                .OrderByDescending(t => t.Resolution.Area)
                .Select(t => t.Url)
                .Distinct()
                .Select(url => new Uri(url))
                .ToList();

            DateTimeOffset? uploadDate = video.UploadDate == default ? null : video.UploadDate;
            var keywords = video.Keywords ?? Array.Empty<string>();

            var additional = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            {
                [MetadataKeys.Provider] = MetadataValues.ProviderYouTube,
                [MetadataKeys.VideoId] = video.Id.Value,
                [MetadataKeys.Channel] = video.Author.ChannelTitle,
                [MetadataKeys.ChannelUrl] = video.Author.ChannelUrl,
                [MetadataKeys.Duration] = video.Duration?.ToString() ?? string.Empty,
                [MetadataKeys.UploadDate] = uploadDate?.ToString("u", CultureInfo.InvariantCulture) ?? string.Empty
            };

            if (video.Engagement?.ViewCount is long views)
            {
                additional[MetadataKeys.ViewCount] = views.ToString(CultureInfo.InvariantCulture);
            }

            if (video.Engagement?.LikeCount is long likes)
            {
                additional[MetadataKeys.LikeCount] = likes.ToString(CultureInfo.InvariantCulture);
            }

            if (keywords.Count > 0)
            {
                additional[MetadataKeys.Tags] = string.Join(", ", keywords);
            }

            return new YouTubeMetadata(
                VideoId: video.Id.Value,
                Title: video.Title,
                ChannelTitle: video.Author.ChannelTitle,
                WatchUrl: new Uri(video.Url),
                ChannelUrl: new Uri(video.Author.ChannelUrl),
                Duration: video.Duration,
                UploadDate: uploadDate,
                ViewCount: video.Engagement?.ViewCount,
                LikeCount: video.Engagement?.LikeCount,
                Tags: keywords.ToArray(),
                Description: video.Description,
                Thumbnails: thumbnails,
                Captions: captions,
                AdditionalMetadata: additional
            );
        }
        catch
        {
            return null;
        }
    }

    private async Task<IReadOnlyList<YouTubeCaptionSegment>> TryGetCaptionsAsync(VideoId videoId, CancellationToken cancellationToken)
    {
        try
        {
            var manifest = await client.Videos.ClosedCaptions.GetManifestAsync(videoId, cancellationToken).ConfigureAwait(false);
            ClosedCaptionTrackInfo? track = null;

            // Prefer English (auto or manual) when available
            track = manifest.Tracks
                .Where(t => string.Equals(t.Language.Code, "en", StringComparison.OrdinalIgnoreCase))
                .OrderByDescending(t => t.IsAutoGenerated ? 0 : 1)
                .FirstOrDefault();

            track ??= manifest.Tracks.FirstOrDefault();
            if (track is null)
            {
                return Array.Empty<YouTubeCaptionSegment>();
            }

            var trackCaptions = await client.Videos.ClosedCaptions.GetAsync(track, cancellationToken).ConfigureAwait(false);
            var segments = new List<YouTubeCaptionSegment>();
            foreach (var caption in trackCaptions.Captions)
            {
                var metadata = new Dictionary<string, string>
                {
                    [MetadataKeys.Provider] = MetadataValues.ProviderYouTube,
                    [MetadataKeys.Language] = track.Language.Code,
                    [MetadataKeys.IsAutoGenerated] = track.IsAutoGenerated.ToString(CultureInfo.InvariantCulture)
                };

                segments.Add(new YouTubeCaptionSegment(
                    Text: caption.Text,
                    Start: caption.Offset,
                    End: caption.Offset + caption.Duration,
                    Metadata: metadata
                ));
            }

            return segments;
        }
        catch
        {
            return Array.Empty<YouTubeCaptionSegment>();
        }
    }
}
